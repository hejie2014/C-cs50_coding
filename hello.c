#include <stdio.h>
#include <string.h>
int main()
{
    int a = 1;
    char *s = "HI!";
    // char *c;  //char *c; 只是声明了一个指针变量，并没有让它指向任何有效的内存。
    // 没有初始化，c 的值是随机的（野指针），你用 c[i] = s[i]; 就会往未知内存写数据，很容易崩溃。

    // char *c = {0};你只是声明了一个指针 c，并没有为它分配内存。在 for 循环里你写 c[i] = s[i];，这会导致野指针写入，程序崩溃（段错误）。
    /*  这行代码只是让指针 c 的值为 0（即 NULL），并没有分配内存空间。
      它的意思是：“c 现在什么都不指向”，而不是“c 指向了一块可以用的内存”。
      char *c = {0}; 只是让 c 指向空（NULL），不能用来存数据。
     必须让 c 指向一块有效的内存，才能用 c[i] = ...。

    char c[10] = {0}; // 推荐，简单安全
      // 或
    char *c = malloc(strlen(s) + 1); // 别忘了 free(c);
     结论：
        1. 不初始化指针直接用，一定是错误的。
        2. 你必须让指针指向有效内存，才能安全赋值。

    */
    char c[10] = {0};
    for (int i = 0; i <= strlen(s); i++) // strlen(s) + 1打印字符串时，会从 c[0] 开始，直到遇到 \0（字符串结束符）
    {
        c[i] = s[i];
    }
    /*  i < strlen(s) + 4
      1. printf("%s\n", c); 打印字符串时，会从 c[0] 开始，直到遇到 \0（字符串结束符）。
      2.  你前面拷贝了 "HI!" 和 \0，所以 c 里前 4 个字节是：'H' 'I' '!' '\0'。
      3. 后面越界写入的内容不会影响前面的字符串内容，也不会影响 \0 的位置。
      4.  所以打印时，printf 只输出到 \0，就是 HI!。


    */
    printf("Hello, World!\n");
    printf("Hello, cs50!\n");
    printf("%p\n", &a);
    printf("%s\n", s);
    printf("%s\n", c);
    return 0;
}